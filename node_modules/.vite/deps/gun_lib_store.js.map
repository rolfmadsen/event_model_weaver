{
  "version": 3,
  "sources": ["../../gun/lib/store.js"],
  "sourcesContent": ["var Gun = (typeof window !== \"undefined\")? window.Gun : require('../gun');\n\nGun.on('create', function(root){\n    if(Gun.TESTING){ root.opt.file = 'radatatest' }\n    this.to.next(root);\n    var opt = root.opt, empty = {}, u;\n    if(false === opt.rad || false === opt.radisk){ return }\n    if((u+'' != typeof process) && 'false' === ''+(process.env||'').RAD){ return }\n    var Radisk = (Gun.window && Gun.window.Radisk) || require('./radisk');\n    var Radix = Radisk.Radix;\n    var dare = Radisk(opt), esc = String.fromCharCode(27);\n    var ST = 0;\n \n    root.on('put', function(msg){\n        this.to.next(msg);\n        if((msg._||'').rad){ return } // don't save what just came from a read.\n        //if(msg['@']){ return } // WHY DID I NOT ADD THIS?\n        var id = msg['#'], put = msg.put, soul = put['#'], key = put['.'], val = put[':'], state = put['>'], tmp;\n        var DBG = (msg._||'').DBG; DBG && (DBG.sp = DBG.sp || +new Date);\n        //var lot = (msg._||'').lot||''; count[id] = (count[id] || 0) + 1; \n        var S = (msg._||'').RPS || ((msg._||'').RPS = +new Date);\n        //console.log(\"PUT ------->>>\", soul,key, val, state);\n        //dare(soul+esc+key, {':': val, '>': state}, dare.one[id] || function(err, ok){\n        dare(soul+esc+key, {':': val, '>': state}, function(err, ok){\n            //console.log(\"<<<------- PAT\", soul,key, val, state, 'in', +new Date - S);\n            DBG && (DBG.spd = DBG.spd || +new Date);\n            console.STAT && console.STAT(S, +new Date - S, 'put');\n            //if(!err && count[id] !== lot.s){ console.log(err = \"Disk count not same as ram count.\"); console.STAT && console.STAT(+new Date, lot.s - count[id], 'put ack != count') } delete count[id];\n            if(err){ root.on('in', {'@': id, err: err, DBG: DBG}); return }\n            root.on('in', {'@': id, ok: ok, DBG: DBG});\n        //}, id, DBG && (DBG.r = DBG.r || {}));\n        }, false && id, DBG && (DBG.r = DBG.r || {}));\n        DBG && (DBG.sps = DBG.sps || +new Date);\n    });\n    var count = {}, obj_empty = Object.empty;\n \n    root.on('get', function(msg){\n        this.to.next(msg);\n        var ctx = msg._||'', DBG = ctx.DBG = msg.DBG; DBG && (DBG.sg = +new Date);\n        var id = msg['#'], get = msg.get, soul = msg.get['#'], has = msg.get['.']||'', o = {}, graph, lex, key, tmp, force;\n        if('string' == typeof soul){\n            key = soul;\n        } else \n        if(soul){\n            if(u !== (tmp = soul['*'])){ o.limit = force = 1 }\n            if(u !== soul['>']){ o.start = soul['>'] }\n            if(u !== soul['<']){ o.end = soul['<'] }\n            key = force? (''+tmp) : tmp || soul['='];\n            force = null;\n        }\n        if(key && !o.limit){ // a soul.has must be on a soul, and not during soul*\n            if('string' == typeof has){\n                key = key+esc+(o.atom = has);\n            } else \n            if(has){\n                if(u !== has['>']){ o.start = has['>']; o.limit = 1 }\n                if(u !== has['<']){ o.end = has['<']; o.limit = 1 }\n                if(u !== (tmp = has['*'])){ o.limit = force = 1 }\n                if(key){ key = key+esc + (force? (''+(tmp||'')) : tmp || (o.atom = has['='] || '')) }\n            }\n        }\n        if((tmp = get['%']) || o.limit){\n            o.limit = (tmp <= (o.pack || (1000 * 100)))? tmp : 1;\n        }\n        if(has['-'] || (soul||{})['-'] || get['-']){ o.reverse = true }\n        if((tmp = (root.next||'')[soul]) && tmp.put){\n            if(o.atom){\n                tmp = (tmp.next||'')[o.atom] ;\n                if(tmp && tmp.root && tmp.root.graph && tmp.root.graph[soul] && tmp.root.graph[soul][o.atom]){ return }\n            } else\n            if(tmp && tmp.rad){ return }\n        }\n        var now = Gun.state();\n        var S = (+new Date), C = 0, SPT = 0; // STATS!\n        DBG && (DBG.sgm = S);\n        //var GID = String.random(3); console.log(\"GET ------->>>\", GID, key, o, '?', get);\n        dare(key||'', function(err, data, info){\n            //console.log(\"<<<------- GOT\", GID, +new Date - S, err, data);\n            DBG && (DBG.sgr = +new Date);\n            DBG && (DBG.sgi = info);\n            try{opt.store.stats.get.time[statg % 50] = (+new Date) - S; ++statg;\n                opt.store.stats.get.count++;\n                if(err){ opt.store.stats.get.err = err }\n            }catch(e){} // STATS!\n            //if(u === data && info.chunks > 1){ return } // if we already sent a chunk, ignore ending empty responses. // this causes tests to fail.\n            console.STAT && console.STAT(S, +new Date - S, 'got', JSON.stringify(key)); S = +new Date;\n            info = info || '';\n            var va, ve;\n            if(info.unit && data && u !== (va = data[':']) && u !== (ve = data['>'])){ // new format\n                var tmp = key.split(esc), so = tmp[0], ha = tmp[1];\n                (graph = graph || {})[so] = Gun.state.ify(graph[so], ha, ve, va, so);\n                root.$.get(so).get(ha)._.rad = now;\n                // REMEMBER TO ADD _rad TO NODE/SOUL QUERY!\n            } else\n            if(data){ // old code path\n                if(typeof data !== 'string'){\n                    if(o.atom){\n                        data = u;\n                    } else {\n                        Radix.map(data, each, o); // IS A RADIX TREE, NOT FUNCTION!\n                    }\n                }\n                if(!graph && data){ each(data, '') }\n                // TODO: !has what about soul lookups?\n                if(!o.atom && !has & 'string' == typeof soul && !o.limit && !o.more){\n                    root.$.get(soul)._.rad = now;\n                }\n            }\n            DBG && (DBG.sgp = +new Date);\n            // TODO: PERF NOTES! This is like 0.2s, but for each ack, or all? Can you cache these preps?\n            // TODO: PERF NOTES! This is like 0.2s, but for each ack, or all? Can you cache these preps?\n            // TODO: PERF NOTES! This is like 0.2s, but for each ack, or all? Can you cache these preps?\n            // TODO: PERF NOTES! This is like 0.2s, but for each ack, or all? Can you cache these preps?\n            // TODO: PERF NOTES! This is like 0.2s, but for each ack, or all? Can you cache these preps?\n            // Or benchmark by reusing first start date.\n            if(console.STAT && (ST = +new Date - S) > 9){ console.STAT(S, ST, 'got prep time'); console.STAT(S, C, 'got prep #') } SPT += ST; C = 0; S = +new Date;\n            var faith = function(){}; faith.faith = true; faith.rad = get; // HNPERF: We're testing performance improvement by skipping going through security again, but this should be audited.\n            root.on('in', {'@': id, put: graph, '%': info.more? 1 : u, err: err? err : u, _: faith, DBG: DBG});\n            console.STAT && (ST = +new Date - S) > 9 && console.STAT(S, ST, 'got emit', Object.keys(graph||{}).length);\n            graph = u; // each is outside our scope, we have to reset graph to nothing!\n        }, o, DBG && (DBG.r = DBG.r || {}));\n        DBG && (DBG.sgd = +new Date);\n        console.STAT && (ST = +new Date - S) > 9 && console.STAT(S, ST, 'get call'); // TODO: Perf: this was half a second??????\n        function each(val, has, a,b){ // TODO: THIS CODE NEEDS TO BE FASTER!!!!\n            C++;\n            if(!val){ return }\n            has = (key+has).split(esc);\n            var soul = has.slice(0,1)[0];\n            has = has.slice(-1)[0];\n            if(o.limit && o.limit <= o.count){ return true }\n            var va, ve, so = soul, ha = has;\n            //if(u !== (va = val[':']) && u !== (ve = val['>'])){ // THIS HANDLES NEW CODE!\n            if('string' != typeof val){ // THIS HANDLES NEW CODE!\n                va = val[':']; ve = val['>'];\n                (graph = graph || {})[so] = Gun.state.ify(graph[so], ha, ve, va, so);\n                //root.$.get(so).get(ha)._.rad = now;\n                o.count = (o.count || 0) + ((va||'').length || 9);\n                return;\n            }\n            o.count = (o.count || 0) + val.length;\n            var tmp = val.lastIndexOf('>');\n            var state = Radisk.decode(val.slice(tmp+1), null, esc);\n            val = Radisk.decode(val.slice(0,tmp), null, esc);\n            (graph = graph || {})[soul] = Gun.state.ify(graph[soul], has, state, val, soul);\n        }\n    });\n    var val_is = Gun.valid;\n    (opt.store||{}).stats = {get:{time:{}, count:0}, put: {time:{}, count:0}}; // STATS!\n    var statg = 0, statp = 0; // STATS!\n});"],
  "mappings": "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",
  "names": ["tmp", "has", "soul"]
}
